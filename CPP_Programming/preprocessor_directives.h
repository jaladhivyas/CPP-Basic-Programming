#ifndef PREPROCESSOR_DIRECTIVES_H
#define PREPROCESSOR_DIRECTIVES_H
#include <iostream>

// Some important points:

//  1. Preprocessor directives are lines included in the code of programs preceded by a hash sign (#).
//  2. The preprocessor examines the code before actual compilation of code begins
//     then it resolves all these directives before any code is actually generated by
//     regular statement.
//  3. It extends only single line of codes. However, Using backslash '\' at end of line
//     one can extend preprocessor directive to more then one line.
//  4. No semicolon is expected on preprocessor directives.

namespace std
{
namespace preprocessor
{

//  Macro definition(#define,#undef)

//  Syntex:
//  #define identifier replacement

//  1. The preprocessor does not understand C++ proper,
//     it simply replaces any occurrence of identifier by replacement in the rest of code
//  2. It's find and replance operation

static void preprocessorMacroDef()
{
  int a = 10, b = 10;
#define getmax(a,b) a > b ? a : b

  int y = getmax(3,2);

// the macro last until it is undefined
#undef getmax(a,b)
  //  y = getmax(a,b);

//  Note:
//  *  Macro definition accept two special operators # and ##
//     the operator #, followed by a parameter name, is replaced
//     by a string literal that contains the argument passed.
#define str(x) #x
cout<<str(test)<<endl;

//  The operator ## concatenates two arguments leaving no blank spaces between them
#define func(a,b) a##b
func(c,out)<<"test"<<endl;

}

//  Conditional Inclusions (#ifdef, #ifndef,#if,#endif,#else and #elif)

//  These directives allow to include or discard part of the code
//  of a program if a certain condition is met
static void preprocessorCondiInc()
{

//  1. #ifdef allows a section of program to be compiled only if the macro
//     that is specified as the parameter is defined
//  2. in this case, array declaration can be done successfully if
//     N is defined using #define
#ifdef N
  int array[N]
#endif

//  #ifndef serves for the exact opposite: the code between #ifndef and #endif
//  directives is only compiled if the specified identifier has not been previously defined.
#ifndef N
 int array[100];
#endif

//  1. Rest of the directives i.e #if, #elif,#else requires some conditions to be met
//     In order for portion of code they surrond to be compiled
//  2. Conditions #if or #elif can only evalute const expressions, including macros
//     expression

#define SIZE 10

#if SIZE >10
#undef SIZE

#elif SIZE <10
#undef SIZE

#else
#undef SIZE
#define SIZE 20
#endif

//  defined and !defined act as same #ifdef and #ifndef
#if !defined SIZE
#define SIZE 30
#endif
}

//  line control, error directive, source file inclusion and pragma directive

//  #line directive

//  1. It tells the compiler that next line of source code is at the line number
//     which has been specified by constant in #line directive.
//  2. It transfer the program control to the line number which has been specified by #line directive.

//  syntex:

//  #line number "filename"
//  The upper limit of #line <integer> preprocessor directives has been increased,
//  from 32,767 to 2,147,483,647 for the C++ preprocessor.

// #error directive

//  This directive aborts the compilation process when it is found.
//  generates a compilation error that can be specified as its parameter:

//  #include directive

//  1. For #include <filename> the preprocessor searches in an implementation dependent manner,
//     normally in search directories pre-designated by the compiler/IDE.
//     This method is normally used to include standard library header files.

//  2. For #include "filename" the preprocessor searches first in the same directory
//     as the file containing the directive, and then follows the search path used for,
//     the #include <filename> form. This method is normally used to include programmer-defined header files.

//  #pragma directive

//  1. This directive is a special purpose directive and is used to turn on or off some features.
//  2. This type of directives are compiler-specific i.e., they vary from compiler to compiler.

static void lineandErrorDirective()
{
#line 159
  int i=90;
  cout<<"This is line number 153 "<<"value of i and Line is "<<i<<__LINE__<<endl;
  cout<<"This is line number 154 "<<"value of i and Line is "<<i<<__LINE__<<endl;
#ifndef __cplusplus
#error A C++ compiler is required!
#endif
}

static void pragmaDirective()
{

//  #pragma once

//  1. It's like a header gard
//  2. It is an instruction to the compiler / preprocessor to include this file once.
//  3. It prevents a header file to include multiple time in single translation unit(.cpp) file.


//  #pragma warn Directive:

//  1. This directive is used to hide the warning messages
//     which are displayed during compilation.

//  #pragma warn +xxx (To show the warning)
//  #pragma warn -xxx (To hide the warning)
//  #pragma warn .xxx (To toggle between hide and show)


//  #pragma warn -rvl:

//  1. This directive hides those warning which are raised when a function
//     which is supposed to return a value does not return a value.

//  #pragma warn -par:

//  2. This directive hides those warning which are raised when a function
//     does not uses the parameters passed to it.

//  #pragma warn -rch:

//  3. This directive hides those warning which are raised when a code is unreachable.
//     For example: any code written after the return statement in a function is unreachable.

//  #pragma GCC poison:

//  1. This directive is supported by the GCC compiler and is used
//     to remove an identifier completely from the program.

//  #pragma GCC poison printf
   int i=0;
   printf("%d",i);
}

static void sampleExamples()
{
//// Example 1.
//  #if X == 3
//    #define Y 3
//  #else
//    #define Y 5
//  #endif
//   printf("%d", Y);


//// Example 2.
//  #define ISEQUAL(X, Y) X == Y

//  #if ISEQUAL(X, 0)
//    printf("It's Equal");
//  #else
//    printf("It's not equal");
//  #endif

//// Example 3.
//   #define square(x) x*x
//     int x;
//   x = 36/square(6);
//   printf("%d", x);

//// Example 4
//  # define scanf  "%s basic c++"
//  printf(scanf,scanf);


//// Example 5
//  #define f(g1,g2) g1##g2
//  int var12 = 100;
//  printf("%d", f(var,12));

//// Example 6
//  #define MAX 1000
//  int MAX = 100;
//  printf("%d ", MAX);
//  return 0;

//// Example 7
//  #define get(s) #s
//  char str[] = get(BasicC++);
//  printf("%s", str);

//// Example 8
//  #define PRINT(i, limit) do \
//                        { \
//                            if (i++ < limit) \
//                            { \
//                                printf("BasicC++\n"); \
//                                continue; \
//                            } \
//                        }while(1)


//  PRINT(0, 3);

}

}

}

#endif // PREPROCESSOR_DIRECTIVES_H
